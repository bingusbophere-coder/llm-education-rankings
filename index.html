<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Best LLMs for Education Rankings</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.datatables.net/2.1.8/css/dataTables.bootstrap5.min.css">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container my-5">
        <h1 class="text-center mb-4">Best LLMs for Education (Dynamic Rankings)</h1>
        <p class="text-center">Ranked by <strong>Privacy</strong>, <strong>Security</strong>, and <strong>Accuracy</strong> (low hallucinations/false info). Higher scores better (out of 10).<br>
        Data auto-fetched from Incogni privacy sheet and Vectara hallucination leaderboard.<br>
        <span id="last-updated">Loading latest data...</span></p>

        <table id="rankingsTable" class="table table-striped table-hover">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Model</th>
                    <th>Provider</th>
                    <th>Privacy</th>
                    <th>Security</th>
                    <th>Accuracy</th>
                    <th>Overall</th>
                    <th>Why for Education?</th>
                </tr>
            </thead>
            <tbody>
                <!-- Filled dynamically by JS -->
            </tbody>
        </table>

        <p class="text-center small mt-4">Open-source models rank higher in privacy/security due to self-hosting options. Data updates live on page load. If fetch fails, try refreshing.</p>
    </div>

    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.datatables.net/2.1.8/js/dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/2.1.8/js/dataTables.bootstrap5.min.js"></script>
    <script>
        // Hardcoded model list (top relevant for education, update if needed)
        const models = [
            {name: "Llama 4", provider: "Meta", openSource: true, why: "Open-source, multilingual, strong reasoning for tutoring and content creation."},
            {name: "Qwen3", provider: "Alibaba", openSource: true, why: "Excellent in math/coding education, efficient for schools."},
            {name: "DeepSeek V3", provider: "DeepSeek", openSource: true, why: "Top open-source reasoning, great for complex topics."},
            {name: "Mistral Large", provider: "Mistral AI", openSource: false, why: "Strong privacy opt-outs, good for agentic tutoring."},
            {name: "Gemma 3", provider: "Google", openSource: true, why: "Fast, efficient for classroom devices."},
            {name: "GPT-5", provider: "OpenAI", openSource: false, why: "Powerful reasoning, paid plans for better privacy."},
            {name: "Grok 4", provider: "xAI", openSource: false, why: "Multimodal for visual learning."},
            {name: "Claude 4", provider: "Anthropic", openSource: false, why: "Excellent feedback, inclusive for special needs."},
            {name: "Gemini 2.5 Pro", provider: "Google", openSource: false, why: "Multimodal research tools."},
            {name: "Phi-4", provider: "Microsoft", openSource: true, why: "Small, low hallucinations, runs on student devices."}
        ];

        // Privacy CSV: https://docs.google.com/spreadsheets/d/1CDUtGAgepi9W9BYosr75lhxZ4m0-EriLcEeHeU6Kbso/export?format=csv
        // Hallucination JSON: https://huggingface.co/spaces/vectara/leaderboard/raw/main/public_leaderboard_data.json

        async function loadData() {
            try {
                const [privacyRes, hallRes] = await Promise.all([
                    fetch('https://docs.google.com/spreadsheets/d/1CDUtGAgepi9W9BYosr75lhxZ4m0-EriLcEeHeU6Kbso/export?format=csv'),
                    fetch('https://huggingface.co/spaces/vectara/leaderboard/raw/main/public_leaderboard_data.json')
                ]);
                const privacyCsv = await privacyRes.text();
                const hallData = await hallRes.json();

                const privacyMap = parsePrivacyCsv(privacyCsv);
                const hallMap = parseHallucinations(hallData);

                const tableData = models.map(m => {
                    const privScore = privacyMap[m.name] || privacyMap[m.provider] || 5; // fallback average
                    const hallRate = hallMap[m.name] || 5; // ~5% average if missing
                    const accScore = Math.max(0, 10 - hallRate * 2); // lower hallucination = higher score
                    const secScore = m.openSource ? 9.5 : 7; // open-source high security
                    const overall = ((privScore + secScore + accScore) / 3).toFixed(1);
                    return { ...m, privacy: privScore.toFixed(1), security: secScore.toFixed(1), accuracy: accScore.toFixed(1), overall };
                });

                tableData.sort((a,b) => b.overall - a.overall);
                tableData.forEach((row, i) => row.rank = i+1);

                renderTable(tableData);
                document.getElementById('last-updated').textContent = `Last updated: ${new Date().toLocaleString()} (live fetch)`;
            } catch (e) {
                document.getElementById('last-updated').textContent = 'Fetch failed - refresh to try again. Using fallback data.';
                renderTable(getFallbackData()); // optional fallback static data
            }
        }

        function parsePrivacyCsv(csv) {
            const lines = csv.split('\n');
            const map = {};
            // Assume first row headers, find columns for model/provider and score
            // Simplified: look for overall score column (adjust if needed from actual sheet)
            // Real sheet has columns like Platform, Overall Score etc.
            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',');
                if (cols.length > 5) {
                    const platform = cols[0].trim().replace(/"/g,'');
                    const score = parseFloat(cols[cols.length-1]) || 5; // last column often overall
                    map[platform] = score;
                }
            }
            return map; // map provider names to scores, adjust mapping in models if needed
        }

        function parseHallucinations(data) {
            const map = {};
            data.forEach(entry => {
                if (entry.model_name) {
                    const rate = parseFloat(entry.hallucination_rate) || 5;
                    map[entry.model_name] = rate / 100; // to decimal
                }
            });
            return map;
        }

        function renderTable(data) {
            const tbody = document.querySelector('#rankingsTable tbody');
            tbody.innerHTML = '';
            data.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${row.rank}</td><td>${row.name}</td><td>${row.provider}</td><td>${row.privacy}</td><td>${row.security}</td><td>${row.accuracy}</td><td>${row.overall}</td><td>${row.why}</td>`;
                tbody.appendChild(tr);
            });
            new DataTable('#rankingsTable', {paging: false, searching: true});
        }

        function getFallbackData() {
            // Your original static data here as fallback
            return [ /* paste previous table rows as objects */ ];
        }

        loadData();
    </script>
</body>
</html>
