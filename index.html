<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Best LLMs for Education Rankings</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.datatables.net/2.1.8/css/dataTables.bootstrap5.min.css">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container my-5">
        <h1 class="text-center mb-4">Best LLMs for Education (Dynamic Rankings - 2025)</h1>
        <p class="text-center">Ranked by <strong>Privacy</strong> (Incogni risk score), <strong>Security</strong> (open-source favored), and <strong>Accuracy</strong> (low hallucinations from Vectara).<br>Higher scores better (out of 10). Data fetched live.<br>
        <span id="last-updated">Loading latest data...</span></p>

        <table id="rankingsTable" class="table table-striped table-hover">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Model</th>
                    <th>Provider</th>
                    <th>Privacy</th>
                    <th>Security</th>
                    <th>Accuracy</th>
                    <th>Overall</th>
                    <th>Why for Education?</th>
                </tr>
            </thead>
            <tbody>
                <!-- Filled dynamically -->
            </tbody>
        </table>

        <p class="text-center small mt-4">Open-source models score higher on security/privacy (self-hosting). Refresh if data fails to load.</p>
    </div>

    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.datatables.net/2.1.8/js/dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/2.1.8/js/dataTables.bootstrap5.min.js"></script>
    <script>
        const models = [
            {name: "Llama 4", provider: "Meta", openSource: true, why: "Open-source, multilingual, strong reasoning for tutoring and content creation.", privacyMap: ["Llama", "Meta"]},
            {name: "Qwen3", provider: "Alibaba", openSource: true, why: "Excellent in math/coding education, efficient for schools.", privacyMap: ["Qwen"]},
            {name: "DeepSeek V3", provider: "DeepSeek", openSource: true, why: "Top open-source reasoning, great for complex topics.", privacyMap: ["DeepSeek"]},
            {name: "Mistral Large", provider: "Mistral AI", openSource: false, why: "Strong privacy opt-outs, good for agentic tutoring.", privacyMap: ["Le Chat Mistral", "Mistral"]},
            {name: "Gemma 3", provider: "Google", openSource: true, why: "Fast, efficient for classroom devices.", privacyMap: ["Gemma", "Google"]},
            {name: "GPT-5", provider: "OpenAI", openSource: false, why: "Powerful reasoning, paid plans for better privacy.", privacyMap: ["ChatGPT", "OpenAI"]},
            {name: "Grok 4", provider: "xAI", openSource: false, why: "Multimodal for visual learning.", privacyMap: ["Grok", "xAI"]},
            {name: "Claude 4", provider: "Anthropic", openSource: false, why: "Excellent feedback, inclusive for special needs.", privacyMap: ["Claude", "Anthropic"]},
            {name: "Gemini 2.5 Pro", provider: "Google", openSource: false, why: "Multimodal research tools.", privacyMap: ["Gemini", "Google"]},
            {name: "Phi-4", provider: "Microsoft", openSource: true, why: "Small, low hallucinations, runs on student devices.", privacyMap: ["Phi", "Microsoft"]}
        ];

        // Full fallback from your original + real known scores
        const fallbackData = [
            {name: "Llama 4", provider: "Meta", privacy: 9.0, security: 10, accuracy: 8.0, overall: 9.0, why: models.find(m => m.name === "Llama 4").why},
            {name: "Mistral Large", provider: "Mistral AI", privacy: 10, security: 9.0, accuracy: 8.0, overall: 9.0, why: models.find(m => m.name === "Mistral Large").why},
            {name: "Qwen3", provider: "Alibaba", privacy: 8.0, security: 10, accuracy: 8.0, overall: 8.7, why: models.find(m => m.name === "Qwen3").why},
            // Add more if desired
        ];

        async function loadData() {
            try {
                const [privacyRes, hallRes] = await Promise.all([
                    fetch('https://docs.google.com/spreadsheets/d/1CDUtGAgepi9W9BYosr75lhxZ4m0-EriLcEeHeU6Kbso/export?format=csv'),
                    fetch('https://raw.githubusercontent.com/vectara/hallucination-leaderboard/main/leaderboard_data.json')
                ]);
                if (!privacyRes.ok || !hallRes.ok) throw new Error('Fetch failed');

                const privacyCsv = await privacyRes.text();
                const hallData = await hallRes.json();

                const privacyMap = parsePrivacyCsv(privacyCsv); // platform/name -> raw risk score (lower better)
                const hallMap = parseHallJson(hallData); // model name -> hallucination %

                const tableData = models.map(m => {
                    // Privacy: find best match, lower raw = better, scale ~ (max 16 -> 0, min 9 ->10)
                    let rawPriv = 16;
                    for (let key of m.privacyMap) {
                        if (privacyMap[key] !== undefined) { rawPriv = Math.min(rawPriv, privacyMap[key]); }
                    }
                    const privScore = (rawPriv <= 9 ? 10 : Math.max(0, 10 - (rawPriv - 9))).toFixed(1);

                    // Accuracy: lower hall % = higher score
                    const hallRate = hallMap[m.name] ?? hallMap[m.provider] ?? 10; // fallback 10%
                    const accScore = Math.max(0, 10 - hallRate).toFixed(1);

                    const secScore = m.openSource ? 9.5 : 7.0;

                    const overall = ((parseFloat(privScore) + secScore + parseFloat(accScoreScore)) / 3).toFixed(1);

                    return { ...m, privacy: privScore, security: secScore.toFixed(1), accuracy: accScore, overall };
                });

                tableData.Sort((a, b) => b.overall - a.overall);
                tableData.forEach((row, i) => row.rank = i + 1);

                renderTable(tableData);
                document.getElementById('last-updated').textContent = `Last updated: ${new Date().toLocaleString()} (live fetch successful)`;
            } catch (e) {
                console.error(e);
                document.getElementById('last-updated').textContent = 'Live fetch failed - using fallback data. Refresh to retry.';
                let tableData = fallbackData.map((row, i) => ({...row, rank: i+1, overall: row.overall.toFixed(1)}));
                renderTable(tableData);
            }
        }

        function parsePrivacyCsv(csv) {
            const lines = csv.split('\n');
            let totalCol = lines[0].split(',').findIndex(h => h.includes('Total score'));
            const map = {};
            for (let line of lines.slice(1)) {
                if (!line.trim()) continue;
                const cols = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/); // better CSV split
                if (cols.length > 1) {
                    let platform = cols[3]?.replace(/"/g, '').trim() || cols[0]?.replace(/"/g, '').trim(); // Agent/model or fallback
                    let score = parseFloat(cols[totalCol]);
                    if (platform && !isNaN(score)) map[platform] = score;
                }
            }
            return map;
        }

        function parseHallJson(data) {
            const map = {};
            // Assume data is array of objects with 'model' and 'hallucination_rate' or similar
            (data.data || data).forEach(entry => {
                let name = entry.model || entry.name || '';
                let rate = parseFloat(entry.hallucination_rate || entry.rate || 10);
                if (name) map[name.trim()] = rate;
            });
            return map;
        }

        function renderTable(data) {
            const tbody = document.querySelector('#rankingsTable tbody');
            tbody.innerHTML = '';
            data.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${row.rank}</td><td>${row.name}</td><td>${row.provider}</td><td>${row.privacy}</td><td>${row.security}</td><td>${row.accuracy}</td><td>${row.overall}</td><td>${row.why}</td>`;
                tbody.appendChild(tr);
            });
            new DataTable('#rankingsTable', {paging: false, searching: true});
        }

        loadData();
    </script>
</body>
</html>
